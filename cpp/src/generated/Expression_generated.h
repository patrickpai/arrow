// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_FLATBUF_H_
#define FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

namespace org {
namespace apache {
namespace arrow {
namespace flatbuf {

enum class CompareOperator : int8_t {
  EQUAL = 0,
  NOT_EQUAL = 1,
  GREATER = 2,
  GREATER_EQUAL = 3,
  LESS = 4,
  LESS_EQUAL = 5,
  MIN = EQUAL,
  MAX = LESS_EQUAL
};

inline const CompareOperator (&EnumValuesCompareOperator())[6] {
  static const CompareOperator values[] = {
    CompareOperator::EQUAL,
    CompareOperator::NOT_EQUAL,
    CompareOperator::GREATER,
    CompareOperator::GREATER_EQUAL,
    CompareOperator::LESS,
    CompareOperator::LESS_EQUAL
  };
  return values;
}

inline const char * const *EnumNamesCompareOperator() {
  static const char * const names[7] = {
    "EQUAL",
    "NOT_EQUAL",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "LESS_EQUAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompareOperator(CompareOperator e) {
  if (flatbuffers::IsOutRange(e, CompareOperator::EQUAL, CompareOperator::LESS_EQUAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompareOperator()[index];
}

enum class ExpressionType : int8_t {
  FIELD = 0,
  SCALAR = 1,
  NOT = 2,
  CAST = 3,
  AND = 4,
  OR = 5,
  COMPARISON = 6,
  IS_VALID = 7,
  IN = 8,
  CUSTOM = 9,
  MIN = FIELD,
  MAX = CUSTOM
};

inline const ExpressionType (&EnumValuesExpressionType())[10] {
  static const ExpressionType values[] = {
    ExpressionType::FIELD,
    ExpressionType::SCALAR,
    ExpressionType::NOT,
    ExpressionType::CAST,
    ExpressionType::AND,
    ExpressionType::OR,
    ExpressionType::COMPARISON,
    ExpressionType::IS_VALID,
    ExpressionType::IN,
    ExpressionType::CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesExpressionType() {
  static const char * const names[11] = {
    "FIELD",
    "SCALAR",
    "NOT",
    "CAST",
    "AND",
    "OR",
    "COMPARISON",
    "IS_VALID",
    "IN",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpressionType(ExpressionType e) {
  if (flatbuffers::IsOutRange(e, ExpressionType::FIELD, ExpressionType::CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpressionType()[index];
}

}  // namespace flatbuf
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_FLATBUF_H_
